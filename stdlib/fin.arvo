import nat.
import option.
import dec.

data fin : nat -> Type :=
| fin_1 : (n : nat) -> fin (S n)
| fin_S : (n : nat) -> fin n -> fin (S n).

check fin_elim : (P : (n : nat) -> fin n -> Type) ->
                 ((n : nat) -> P (S n) (fin_1 n)) ->
                 ((n : nat) -> (x : fin n) -> P n x -> P (S n) (fin_S n x)) ->
                 (n : nat) -> (x : fin n) -> P n x.

def fin_option : nat -> Type :=
  nat_elim (\_. Type)
    False
    (\n. \rec. option rec)
  .

def fin_to_fin_option : (n : nat) -> fin n -> fin_option n :=
  fin_elim (\z. \w. fin_option z)
    (\n. none (fin_option n))
    (\n. \x. \Px. some (fin_option n) Px)
  .

simpl fin_to_fin_option (S O) (fin_1 O).
simpl fin_to_fin_option (S (S O)) (fin_S (S O) (fin_1 O)).

def fin_option_to_fin : (n : nat) -> fin_option n -> fin n :=
  nat_elim (\z. fin_option z -> fin z)
    (\H : False. exfalso H (fin O))
    (\n. \rec : fin_option n -> fin n.
      option_case_simple (fin_option n) (fin (S n))
        (fin_1 n)
        (\x : fin_option n. fin_S n (rec x)))
  .

simpl fin_option_to_fin (S O) (none (fin_option O)).

def fin_to_nat : (n : nat) -> fin n -> nat :=
  fin_elim (\_. \_. nat)
    (\_. O)
    (\_. \_. S)
  .

simpl fin_to_nat (S (S O)) (fin_S (S O) (fin_1 O)).

def fin_O_False : fin O -> False :=
  \x.
    fin_elim (\z. \_. nat_elim (\_. Type) True (\_. \_. False) z -> fin z -> False)
      (\_. \H : False. \_. H)
      (\_. \_. \_. \H : False. \_. H)
      O
      x
      I
      x
  .

def fin_case_S : (P : (n : nat) -> fin (S n) -> Type) ->
                 ((n : nat) -> P n (fin_1 n)) ->
                 ((n : nat) -> (x : fin n) -> P n (fin_S n x)) ->
                 (n : nat) -> (x : fin (S n)) -> P n x :=
  \P. \o. \s. \n. \x.
    fin_elim (\z. \w. nat_elim (\z0. fin z0 -> Type)
                               (\_. True)
                               (\k. \_. \w0 : fin (S k). P k w0)
                               z
                               w)
      (\m. o m)
      (\m. \x. \_. s m x)
      (S n)
      x
  .

def O_S_inv : (n : nat) -> eq nat O (S n) -> False :=
  \n.
    subst nat
        (nat_elim (\_. Type) True (\_. \_. False))
        O
        I
        (S n)
  .

def fin_1_S_inv : (n : nat) -> (x : fin n) -> eq (fin (S n)) (fin_1 n) (fin_S n x) -> False :=
  \n. \x.
    subst (fin (S n))
      (fin_elim (\_. \_. Type) (\_. True) (\_. \_. \_. False) (S n))
      (fin_1 n)
      I
      (fin_S n x)
  .

@wow@
def fin_S_injective : (n : nat) -> (x y : fin n) ->
                      eq (fin (S n)) (fin_S n x) (fin_S n y) ->
                      eq (fin n) x y :=
  \n. \x. \y. \H.
    subst (fin (S n))
      (\a : fin (S n).
        fin_elim (\z. \_. nat_elim (\_. Type) Type (\k. \_. fin k -> Type) z)
          (\m. \_. True)
          (\m : nat. \b : fin m. \_. \z : fin m. eq (fin m) z b)
          (S n)
          a x)
      (fin_S n x)
      (refl (fin n) x)
      (fin_S n y)
      H
  .

def fin_eq_dec : (n : nat) -> (x y : fin n) -> dec (eq (fin n) x y) :=
  fin_elim (\z. \w. (y : fin z) -> dec (eq (fin z) w y))
    (fin_case_S (\z. \w. dec (eq (fin (S z)) (fin_1 z) w))
      (\n. dec_yes (eq (fin (S n)) (fin_1 n) (fin_1 n)) (refl (fin (S n)) (fin_1 n)))
      (\n. \y. dec_no (eq (fin (S n)) (fin_1 n) (fin_S n y)) (fin_1_S_inv n y)))
    (\n. \x : fin n. \rec : (y : fin n) -> dec (eq (fin n) x y). \y : fin (S n).
       fin_case_S (\z. \w : fin (S z).
                     (x : fin z) -> ((y : fin z) -> dec (eq (fin z) x y)) ->
                     dec (eq (fin (S z)) (fin_S z x) w))
         (\n. \x : fin n. \rec.
           dec_no (eq (fin (S n)) (fin_S n x) (fin_1 n))
             (\H : eq (fin (S n)) (fin_S n x) (fin_1 n).
             (fin_1_S_inv n x
               (eq_sym (fin (S n)) (fin_S n x) (fin_1 n) H))))
         (\n. \y : fin n. \x : fin n. \rec : (z : fin n) -> dec (eq (fin n) x z).
           dec_case_simple (eq (fin n) x y) (dec (eq (fin (S n)) (fin_S n x) (fin_S n y)))
             (\H : eq (fin n) x y. dec_yes (eq (fin (S n)) (fin_S n x) (fin_S n y))
               (f_equal (fin n) (fin (S n)) (fin_S n) x y H))
             (\H : eq (fin n) x y -> False.
               dec_no (eq (fin (S n)) (fin_S n x) (fin_S n y))
                 (\Hs : eq (fin (S n)) (fin_S n x) (fin_S n y).
                   H (fin_S_injective n x y Hs)))
             (rec y))
         n
         y
         x
         rec)
  .
