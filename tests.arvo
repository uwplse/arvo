def pair : Type -> Type -> Type := \A : Type. \B : Type. (C : Type) -> (A -> B -> C) -> C.
axiom True : Type.
axiom True_intro : True.
axiom and : Type -> Type -> Type.
axiom and_intro : (A B : Type) -> A -> B -> and A B.
axiom and_elim : (A B C : Type) -> (A -> B -> C) -> and A B -> C.
def iff : Type -> Type -> Type := \A : Type. \B : Type. and (A -> B) (B -> A).
def iff_intro : (A B : Type) -> (A -> B) -> (B -> A) -> iff A B :=
    \A : Type. \B : Type. \f : A -> B. \g : B -> A. and_intro (A -> B) (B -> A) f g.

compute pair.
compute ((\x:Type. x) Type).

print pair.
print iff_intro.

data False := .
print False.
compute False.
print False_elim.
compute False_elim.

axiom admit : False.

def bad : (A : Type) -> A := \A : Type. False_elim (\_ : False. A) admit.
print bad.
compute bad.
compute bad Type.

check False.
check bad.
check pair.
check False_elim.
check (P : False -> Type) -> (x : False) -> P x.

data unit := tt.
print tt.
compute tt.
check tt.
print unit.
compute unit.
check unit.
check unit_elim.
compute unit_elim.
print unit_elim.
compute (unit_elim (\_:unit. unit) tt tt).

data bool := true | false.
check bool.
print bool.
compute bool.
check true.
print true.
compute true.
check false.
print false.
compute false.
check bool_elim.
print bool_elim.

def negb : bool -> bool := bool_elim (\_:bool. bool) false true.
check negb.
print negb.
compute negb true.
compute negb false.

def andb : bool -> bool -> bool := bool_elim (\_:bool. bool -> bool) (\x:bool. x) (\_:bool. false).
check andb.
print andb.
compute andb true true.
compute andb true false.
compute andb false true.
compute andb false false.
